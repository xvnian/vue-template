<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Title</title>
  <script src="https://unpkg.com/@reactivex/rxjs@5.5.11/dist/global/Rx.js"></script>
</head>
<body>
  <button>test</button>
</body>
</html>
<script>
  // var button = document.querySelector('button');
  //
  // Rx.Observable.fromEvent(button, 'click')
  //   .throttleTime(1000)
  //   .map(event => event.ClientX)
  //   .scan((count, clientX) => count + clientX, 0)
  //   .subscribe(count => console.log(count));


  // const ob = Rx.Observable.interval(1000);
  // ob.take(3).map(n => n * 2).filter(n => n > 0).subscribe(n => console.log(n));

  // var foo = Rx.Observable.create(function (observer) {
  //   console.log('hello');
  //   observer.next(42);
  //   observer.next(100); // '返回‘另外一个值
  //   observer.next(200); // 同上
  //   setTimeout(() => {
  //     observer.next(300);
  //   }, 1000);
  // });
  //
  // console.log('before');
  // foo.subscribe(function (x) {
  //   console.log(x);
  // });
  // console.log('after');


  // var observable = Rx.Observable.create(function subscribe(observer) {
  //   var id = setInterval(() => {
  //     observer.next('hi');
  //   }, 1000);
  // });
  //
  // observable.subscribe(function (x) {
  //   console.log(x);
  // });


  // var observable = Rx.Observable.from([10,20,30]);
  // var subscription = observable.subscribe(x => console.log(x));
  // // 一段时间以后
  // // subscription.unsubscribe();
  //
  // observable.subscribe(
  //   x => console.log('Observer got a next value: ' + x),
  //   err => console.error('Observer got an error: ' + err),
  //   () => console.log('Observer got a complete notification')
  // );


  // var observable = Rx.Observable.interval(1000);
  // var subscription = observable.subscribe(x => console.log(x));
  // // 执行一段时间后

  // 下面的操作将会取消上面已经订阅的 Observable 的执行。
  // subscription.unsubscribe();


  // var observable1 = Rx.Observable.interval(400);
  // var observable2 = Rx.Observable.interval(300);
  //
  // var subscription = observable1.subscribe(x => console.log('first: ' + x));
  //
  // var childSubscription = observable2.subscribe(x => console.log('second: ' + x));
  //
  // subscription.add(childSubscription);
  //
  // setTimeout(() => {
  //   // 取消上面的两次订阅
  //   subscription.unsubscribe();
  // }, 1000);


  // var subject = new Rx.Subject();
  //
  // subject.subscribe({
  //   next: v => console.log('observerA: ' + v)
  // });
  //
  // subject.subscribe({
  //   next: v => console.log('observerB: ' + v)
  // });
  //
  // subject.next(1);
  // subject.next(2);


  // var subject = new Rx.Subject();
  //
  // subject.subscribe({
  //   next: v => console.log('observerA: ' + v)
  // });
  //
  // subject.subscribe({
  //   next: v => console.log('observerB: ' + v)
  // });
  //
  // var observable = Rx.Observable.from([1, 2, 3]);
  //
  // observable.subscribe(subject);


  // var source = Rx.Observable.from([1, 2, 3]);
  // var subject = new Rx.Subject();
  // var multicasted = source.multicast(subject);
  //
  // multicasted.subscribe({
  //
  //   next: v => console.log('observerA: ' + v)
  // });
  // multicasted.subscribe({
  //
  //   next: v => console.log('observerB: ' + v)
  // });
  //
  // multicasted.connect();


  // var source = Rx.Observable.interval(500);
  // var subject = new Rx.Subject();
  // var multicasted = source.multicast(subject);
  // var subscription1, subscription2, subscriptionConnect;
  //
  // subscription1 = multicasted.subscribe({
  //   next: v => console.log('observerA: ' + v)
  // });
  //
  // // 在这里我们需要显示的调用connect方法以使第一个订阅者可以开始接收值
  // subscriptionConnect = multicasted.connect();
  //
  // setTimeout(() => {
  //   subscription2 = multicasted.subscribe({
  //     next: v => console.log('observerB: ' + v)
  //   });
  // }, 600);
  //
  // setTimeout(() => {
  //   subscription1.unsubscribe();
  // }, 1200);
  //
  // // 在这里我们需要把多播流的订阅取消掉，因为从此以后再也没有订阅者订阅它了。
  // setTimeout(() => {
  //   subscription2.unsubscribe();
  //   subscriptionConnect.unsubscribe();
  // }, 2000);



  // var source = Rx.Observable.interval(500);
  // var subject = new Rx.Subject();
  // var refCounted = source.multicast(subject).refCount();
  // var subscription1, subscription2, subscriptionConnect;
  //
  // // 这次调用会执行connect方法
  // console.log('observerA subscribed');
  // subscription1 = refCounted.subscribe({
  //   next: v => console.log('observerA: ' + v)
  // });
  //
  // setTimeout(() => {
  //   console.log('observerB subscribed');
  //   subscription2 = refCounted.subscribe({
  //     next: v => console.log('observerB: ' + v)
  //   })
  // },600);
  //
  // setTimeout(() => {
  //   console.log('observerA unsubscribed');
  //   subscription1.unsubscribe();
  // }, 1200);
  //
  // // 这里会调用多播流的unsubscribe方法
  // setTimeout(() => {
  //   console.log('observerB unsubscribed');
  //   subscription2.unsubscribe();
  // },2000);

  console.log(11)
  console.log(22)
  console.log(3)
</script>
